// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/bbs/db"
	"github.com/cloudfoundry-incubator/bbs/models"
	"github.com/pivotal-golang/lager"
)

type FakeEventDB struct {
	WatchForActualLRPChangesStub        func(lager.Logger, func(created *models.ActualLRPGroup), func(changed *models.ActualLRPChange), func(deleted *models.ActualLRPGroup)) (chan<- bool, <-chan error)
	watchForActualLRPChangesMutex       sync.RWMutex
	watchForActualLRPChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.ActualLRPGroup)
		arg3 func(changed *models.ActualLRPChange)
		arg4 func(deleted *models.ActualLRPGroup)
	}
	watchForActualLRPChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
	WatchForDesiredLRPChangesStub        func(lager.Logger, func(created *models.DesiredLRP), func(changed *models.DesiredLRPChange), func(deleted *models.DesiredLRP)) (chan<- bool, <-chan error)
	watchForDesiredLRPChangesMutex       sync.RWMutex
	watchForDesiredLRPChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.DesiredLRP)
		arg3 func(changed *models.DesiredLRPChange)
		arg4 func(deleted *models.DesiredLRP)
	}
	watchForDesiredLRPChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
	WatchForTaskChangesStub        func(lager.Logger, func(created *models.Task), func(changed *models.TaskChange), func(deleted *models.Task)) (chan<- bool, <-chan error)
	watchForTaskChangesMutex       sync.RWMutex
	watchForTaskChangesArgsForCall []struct {
		arg1 lager.Logger
		arg2 func(created *models.Task)
		arg3 func(changed *models.TaskChange)
		arg4 func(deleted *models.Task)
	}
	watchForTaskChangesReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
}

func (fake *FakeEventDB) WatchForActualLRPChanges(arg1 lager.Logger, arg2 func(created *models.ActualLRPGroup), arg3 func(changed *models.ActualLRPChange), arg4 func(deleted *models.ActualLRPGroup)) (chan<- bool, <-chan error) {
	fake.watchForActualLRPChangesMutex.Lock()
	fake.watchForActualLRPChangesArgsForCall = append(fake.watchForActualLRPChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.ActualLRPGroup)
		arg3 func(changed *models.ActualLRPChange)
		arg4 func(deleted *models.ActualLRPGroup)
	}{arg1, arg2, arg3, arg4})
	fake.watchForActualLRPChangesMutex.Unlock()
	if fake.WatchForActualLRPChangesStub != nil {
		return fake.WatchForActualLRPChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForActualLRPChangesReturns.result1, fake.watchForActualLRPChangesReturns.result2
	}
}

func (fake *FakeEventDB) WatchForActualLRPChangesCallCount() int {
	fake.watchForActualLRPChangesMutex.RLock()
	defer fake.watchForActualLRPChangesMutex.RUnlock()
	return len(fake.watchForActualLRPChangesArgsForCall)
}

func (fake *FakeEventDB) WatchForActualLRPChangesArgsForCall(i int) (lager.Logger, func(created *models.ActualLRPGroup), func(changed *models.ActualLRPChange), func(deleted *models.ActualLRPGroup)) {
	fake.watchForActualLRPChangesMutex.RLock()
	defer fake.watchForActualLRPChangesMutex.RUnlock()
	return fake.watchForActualLRPChangesArgsForCall[i].arg1, fake.watchForActualLRPChangesArgsForCall[i].arg2, fake.watchForActualLRPChangesArgsForCall[i].arg3, fake.watchForActualLRPChangesArgsForCall[i].arg4
}

func (fake *FakeEventDB) WatchForActualLRPChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForActualLRPChangesStub = nil
	fake.watchForActualLRPChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeEventDB) WatchForDesiredLRPChanges(arg1 lager.Logger, arg2 func(created *models.DesiredLRP), arg3 func(changed *models.DesiredLRPChange), arg4 func(deleted *models.DesiredLRP)) (chan<- bool, <-chan error) {
	fake.watchForDesiredLRPChangesMutex.Lock()
	fake.watchForDesiredLRPChangesArgsForCall = append(fake.watchForDesiredLRPChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.DesiredLRP)
		arg3 func(changed *models.DesiredLRPChange)
		arg4 func(deleted *models.DesiredLRP)
	}{arg1, arg2, arg3, arg4})
	fake.watchForDesiredLRPChangesMutex.Unlock()
	if fake.WatchForDesiredLRPChangesStub != nil {
		return fake.WatchForDesiredLRPChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForDesiredLRPChangesReturns.result1, fake.watchForDesiredLRPChangesReturns.result2
	}
}

func (fake *FakeEventDB) WatchForDesiredLRPChangesCallCount() int {
	fake.watchForDesiredLRPChangesMutex.RLock()
	defer fake.watchForDesiredLRPChangesMutex.RUnlock()
	return len(fake.watchForDesiredLRPChangesArgsForCall)
}

func (fake *FakeEventDB) WatchForDesiredLRPChangesArgsForCall(i int) (lager.Logger, func(created *models.DesiredLRP), func(changed *models.DesiredLRPChange), func(deleted *models.DesiredLRP)) {
	fake.watchForDesiredLRPChangesMutex.RLock()
	defer fake.watchForDesiredLRPChangesMutex.RUnlock()
	return fake.watchForDesiredLRPChangesArgsForCall[i].arg1, fake.watchForDesiredLRPChangesArgsForCall[i].arg2, fake.watchForDesiredLRPChangesArgsForCall[i].arg3, fake.watchForDesiredLRPChangesArgsForCall[i].arg4
}

func (fake *FakeEventDB) WatchForDesiredLRPChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForDesiredLRPChangesStub = nil
	fake.watchForDesiredLRPChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeEventDB) WatchForTaskChanges(arg1 lager.Logger, arg2 func(created *models.Task), arg3 func(changed *models.TaskChange), arg4 func(deleted *models.Task)) (chan<- bool, <-chan error) {
	fake.watchForTaskChangesMutex.Lock()
	fake.watchForTaskChangesArgsForCall = append(fake.watchForTaskChangesArgsForCall, struct {
		arg1 lager.Logger
		arg2 func(created *models.Task)
		arg3 func(changed *models.TaskChange)
		arg4 func(deleted *models.Task)
	}{arg1, arg2, arg3, arg4})
	fake.watchForTaskChangesMutex.Unlock()
	if fake.WatchForTaskChangesStub != nil {
		return fake.WatchForTaskChangesStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.watchForTaskChangesReturns.result1, fake.watchForTaskChangesReturns.result2
	}
}

func (fake *FakeEventDB) WatchForTaskChangesCallCount() int {
	fake.watchForTaskChangesMutex.RLock()
	defer fake.watchForTaskChangesMutex.RUnlock()
	return len(fake.watchForTaskChangesArgsForCall)
}

func (fake *FakeEventDB) WatchForTaskChangesArgsForCall(i int) (lager.Logger, func(created *models.Task), func(changed *models.TaskChange), func(deleted *models.Task)) {
	fake.watchForTaskChangesMutex.RLock()
	defer fake.watchForTaskChangesMutex.RUnlock()
	return fake.watchForTaskChangesArgsForCall[i].arg1, fake.watchForTaskChangesArgsForCall[i].arg2, fake.watchForTaskChangesArgsForCall[i].arg3, fake.watchForTaskChangesArgsForCall[i].arg4
}

func (fake *FakeEventDB) WatchForTaskChangesReturns(result1 chan<- bool, result2 <-chan error) {
	fake.WatchForTaskChangesStub = nil
	fake.watchForTaskChangesReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

var _ db.EventDB = new(FakeEventDB)
