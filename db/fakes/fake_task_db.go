// This file was generated by counterfeiter
package fakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/bbs/db"
	"github.com/cloudfoundry-incubator/bbs/models"
	"github.com/pivotal-golang/lager"
)

type FakeTaskDB struct {
	TasksStub        func(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, *models.Error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		logger lager.Logger
		filter models.TaskFilter
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 *models.Error
	}
	TaskByGuidStub        func(logger lager.Logger, processGuid string) (*models.Task, *models.Error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 *models.Error
	}
	DesireTaskStub        func(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid, domain string) *models.Error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}
	desireTaskReturns struct {
		result1 *models.Error
	}
	StartTaskStub        func(logger lager.Logger, taskGuid, cellId string) (bool, *models.Error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}
	startTaskReturns struct {
		result1 bool
		result2 *models.Error
	}
	CancelTaskStub        func(logger lager.Logger, taskGuid string) *models.Error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 *models.Error
	}
	FailTaskStub        func(logger lager.Logger, taskGuid, failureReason string) *models.Error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 *models.Error
	}
	CompleteTaskStub        func(logger lager.Logger, taskGuid, cellId string, failed bool, failureReason, result string) *models.Error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 *models.Error
	}
	ResolvingTaskStub        func(logger lager.Logger, taskGuid string) *models.Error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 *models.Error
	}
	ResolveTaskStub        func(logger lager.Logger, taskGuid string) *models.Error
	resolveTaskMutex       sync.RWMutex
	resolveTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolveTaskReturns struct {
		result1 *models.Error
	}
	ConvergeTasksStub        func(logger lager.Logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration time.Duration)
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}
}

func (fake *FakeTaskDB) Tasks(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, *models.Error) {
	fake.tasksMutex.Lock()
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		logger lager.Logger
		filter models.TaskFilter
	}{logger, filter})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub(logger, filter)
	} else {
		return fake.tasksReturns.result1, fake.tasksReturns.result2
	}
}

func (fake *FakeTaskDB) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeTaskDB) TasksArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return fake.tasksArgsForCall[i].logger, fake.tasksArgsForCall[i].filter
}

func (fake *FakeTaskDB) TasksReturns(result1 []*models.Task, result2 *models.Error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeTaskDB) TaskByGuid(logger lager.Logger, processGuid string) (*models.Task, *models.Error) {
	fake.taskByGuidMutex.Lock()
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(logger, processGuid)
	} else {
		return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
	}
}

func (fake *FakeTaskDB) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeTaskDB) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].logger, fake.taskByGuidArgsForCall[i].processGuid
}

func (fake *FakeTaskDB) TaskByGuidReturns(result1 *models.Task, result2 *models.Error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeTaskDB) DesireTask(logger lager.Logger, taskDefinition *models.TaskDefinition, taskGuid string, domain string) *models.Error {
	fake.desireTaskMutex.Lock()
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		logger         lager.Logger
		taskDefinition *models.TaskDefinition
		taskGuid       string
		domain         string
	}{logger, taskDefinition, taskGuid, domain})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(logger, taskDefinition, taskGuid, domain)
	} else {
		return fake.desireTaskReturns.result1
	}
}

func (fake *FakeTaskDB) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeTaskDB) DesireTaskArgsForCall(i int) (lager.Logger, *models.TaskDefinition, string, string) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].logger, fake.desireTaskArgsForCall[i].taskDefinition, fake.desireTaskArgsForCall[i].taskGuid, fake.desireTaskArgsForCall[i].domain
}

func (fake *FakeTaskDB) DesireTaskReturns(result1 *models.Error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) StartTask(logger lager.Logger, taskGuid string, cellId string) (bool, *models.Error) {
	fake.startTaskMutex.Lock()
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
		cellId   string
	}{logger, taskGuid, cellId})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(logger, taskGuid, cellId)
	} else {
		return fake.startTaskReturns.result1, fake.startTaskReturns.result2
	}
}

func (fake *FakeTaskDB) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeTaskDB) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].logger, fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellId
}

func (fake *FakeTaskDB) StartTaskReturns(result1 bool, result2 *models.Error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 *models.Error
	}{result1, result2}
}

func (fake *FakeTaskDB) CancelTask(logger lager.Logger, taskGuid string) *models.Error {
	fake.cancelTaskMutex.Lock()
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(logger, taskGuid)
	} else {
		return fake.cancelTaskReturns.result1
	}
}

func (fake *FakeTaskDB) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeTaskDB) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].logger, fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeTaskDB) CancelTaskReturns(result1 *models.Error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) FailTask(logger lager.Logger, taskGuid string, failureReason string) *models.Error {
	fake.failTaskMutex.Lock()
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}{logger, taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(logger, taskGuid, failureReason)
	} else {
		return fake.failTaskReturns.result1
	}
}

func (fake *FakeTaskDB) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeTaskDB) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].logger, fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeTaskDB) FailTaskReturns(result1 *models.Error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) CompleteTask(logger lager.Logger, taskGuid string, cellId string, failed bool, failureReason string, result string) *models.Error {
	fake.completeTaskMutex.Lock()
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(logger, taskGuid, cellId, failed, failureReason, result)
	} else {
		return fake.completeTaskReturns.result1
	}
}

func (fake *FakeTaskDB) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeTaskDB) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].logger, fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeTaskDB) CompleteTaskReturns(result1 *models.Error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) ResolvingTask(logger lager.Logger, taskGuid string) *models.Error {
	fake.resolvingTaskMutex.Lock()
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(logger, taskGuid)
	} else {
		return fake.resolvingTaskReturns.result1
	}
}

func (fake *FakeTaskDB) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeTaskDB) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].logger, fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeTaskDB) ResolvingTaskReturns(result1 *models.Error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) ResolveTask(logger lager.Logger, taskGuid string) *models.Error {
	fake.resolveTaskMutex.Lock()
	fake.resolveTaskArgsForCall = append(fake.resolveTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.resolveTaskMutex.Unlock()
	if fake.ResolveTaskStub != nil {
		return fake.ResolveTaskStub(logger, taskGuid)
	} else {
		return fake.resolveTaskReturns.result1
	}
}

func (fake *FakeTaskDB) ResolveTaskCallCount() int {
	fake.resolveTaskMutex.RLock()
	defer fake.resolveTaskMutex.RUnlock()
	return len(fake.resolveTaskArgsForCall)
}

func (fake *FakeTaskDB) ResolveTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolveTaskMutex.RLock()
	defer fake.resolveTaskMutex.RUnlock()
	return fake.resolveTaskArgsForCall[i].logger, fake.resolveTaskArgsForCall[i].taskGuid
}

func (fake *FakeTaskDB) ResolveTaskReturns(result1 *models.Error) {
	fake.ResolveTaskStub = nil
	fake.resolveTaskReturns = struct {
		result1 *models.Error
	}{result1}
}

func (fake *FakeTaskDB) ConvergeTasks(logger lager.Logger, kickTaskDuration time.Duration, expirePendingTaskDuration time.Duration, expireCompletedTaskDuration time.Duration) {
	fake.convergeTasksMutex.Lock()
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}{logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		fake.ConvergeTasksStub(logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration)
	}
}

func (fake *FakeTaskDB) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeTaskDB) ConvergeTasksArgsForCall(i int) (lager.Logger, time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].logger, fake.convergeTasksArgsForCall[i].kickTaskDuration, fake.convergeTasksArgsForCall[i].expirePendingTaskDuration, fake.convergeTasksArgsForCall[i].expireCompletedTaskDuration
}

var _ db.TaskDB = new(FakeTaskDB)
