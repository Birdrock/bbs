// This file was generated by counterfeiter
package watcherfakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/bbs/models"
	"github.com/cloudfoundry-incubator/bbs/watcher"
	"github.com/pivotal-golang/lager"
)

type FakeEventStreamer struct {
	StreamStub        func(logger lager.Logger, eventChan chan<- models.Event) (stop chan<- bool, error <-chan error)
	streamMutex       sync.RWMutex
	streamArgsForCall []struct {
		logger    lager.Logger
		eventChan chan<- models.Event
	}
	streamReturns struct {
		result1 chan<- bool
		result2 <-chan error
	}
}

func (fake *FakeEventStreamer) Stream(logger lager.Logger, eventChan chan<- models.Event) (stop chan<- bool, error <-chan error) {
	fake.streamMutex.Lock()
	fake.streamArgsForCall = append(fake.streamArgsForCall, struct {
		logger    lager.Logger
		eventChan chan<- models.Event
	}{logger, eventChan})
	fake.streamMutex.Unlock()
	if fake.StreamStub != nil {
		return fake.StreamStub(logger, eventChan)
	} else {
		return fake.streamReturns.result1, fake.streamReturns.result2
	}
}

func (fake *FakeEventStreamer) StreamCallCount() int {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	return len(fake.streamArgsForCall)
}

func (fake *FakeEventStreamer) StreamArgsForCall(i int) (lager.Logger, chan<- models.Event) {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	return fake.streamArgsForCall[i].logger, fake.streamArgsForCall[i].eventChan
}

func (fake *FakeEventStreamer) StreamReturns(result1 chan<- bool, result2 <-chan error) {
	fake.StreamStub = nil
	fake.streamReturns = struct {
		result1 chan<- bool
		result2 <-chan error
	}{result1, result2}
}

var _ watcher.EventStreamer = new(FakeEventStreamer)
